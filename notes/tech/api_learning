好的，这是一份根据您提供的学习笔记，重新组织和润色后的 FastAPI 实战指南。

这份笔记从一个简单的 API 开始，逐步增加文件上传、词频统计、日志、安全认证等高级功能，最后详细介绍了如何使用 Docker 和直接部署到云服务器两种主流方式，形成了一个完整的学习和查阅手册。

---

## **FastAPI 实战笔记：从零到一构建、扩展与部署 API**

### **第一部分：构建核心 API - “单词统计服务”**

#### **1.1 目标场景**
创建一个后端服务，接收用户发送的一段文本，并返回文本中的单词数量。

#### **1.2 技术栈**
| 工具 | 用途 |
| :--- | :--- |
| Python | 编程语言 |
| FastAPI | 高效构建 Web API 的 Python 框架 |
| Uvicorn | ASGI 服务器，用于启动 FastAPI 应用 |

#### **1.3 环境准备**
首次使用需安装必要的库：
```bash
pip install fastapi uvicorn
```

#### **1.4 编写核心代码 (`main.py`)**
```python
from fastapi import FastAPI
from pydantic import BaseModel

# 初始化 FastAPI 应用
app = FastAPI(title="Word Count API")

# 定义 API 的请求和响应数据模型
class WordCountRequest(BaseModel):
    text: str

class WordCountResponse(BaseModel):
    word_count: int
    original_text: str

# 根路由，用于检查服务是否运行
@app.get("/")
def root():
    return {"message": "Word Count API is running!"}

# 定义单词统计接口
@app.post("/count_words", response_model=WordCountResponse)
def count_words(request: WordCountRequest):
    text = request.text.strip()
    words = text.split()
    return WordCountResponse(
        word_count=len(words),
        original_text=text
    )
```

#### **1.5 启动服务**
在终端中运行以下命令：
```bash
uvicorn main:app --reload
```
*   `main`: 指的是 `main.py` 文件。
*   `app`: 指的是在 `main.py` 中创建的 `FastAPI()` 实例。
*   `--reload`: 代码变更后，服务会自动重启。

服务启动后，你将看到类似输出：
```
Uvicorn running on http://127.0.0.1:8000
```

#### **1.6 测试 API**

*   **方法一：通过 Swagger UI 交互式文档 (推荐)**
    访问浏览器： **`http://127.0.0.1:8000/docs`**
    这是一个自动生成的 API 文档页面，你可以在这里直接测试你的接口。

*   **方法二：通过命令行 `curl` 调用**
    ```bash
    curl -X POST http://127.0.0.1:8000/count_words \
      -H "Content-Type: application/json" \
      -d '{"text": "Hello world! This is a test."}'
    ```
    **预期返回:**
    ```json
    {
      "word_count": 6,
      "original_text": "Hello world! This is a test."
    }
    ```

---

### **第二部分：扩展 API 功能**

#### **2.1 功能扩展：支持 `.txt` 文件上传**
修改 `main.py`，增加一个用于处理文件上传的新接口。

```python
# 在 main.py 顶部添加导入
from fastapi import UploadFile, File, HTTPException

@app.post("/count_words_file", response_model=WordCountResponse)
async def count_words_file(file: UploadFile = File(...)):
    # 1. 校验文件扩展名
    if not file.filename.endswith(".txt"):
        raise HTTPException(status_code=400, detail="Only .txt files are supported")

    # 2. 异步读取文件内容 (二进制)
    contents = await file.read()
    # 3. 将二进制解码为 utf-8 字符串
    text = contents.decode("utf-8").strip()

    # 4. 统计单词数量
    words = text.split()
    return WordCountResponse(
        word_count=len(words),
        original_text=text
    )
```
**测试方法 (`curl`):**
```bash
# 确保你有一个名为 test.txt 的文件在当前目录
curl -X POST http://127.0.0.1:8000/count_words_file \
  -H "Content-Type: multipart/form-data" \
  -F "file=@test.txt"
```

#### **2.2 功能扩展：词频统计并提供下载**
创建一个新接口，用于分析上传文本的词频，并将结果保存为 `.json` 或 `.csv` 文件供用户下载。

```python
# 在 main.py 顶部添加导入
import os
import json
import csv
import tempfile
from collections import Counter
from typing import Dict
from datetime import datetime
from fastapi.responses import FileResponse

@app.post("/word_frequencies_file")
async def word_frequencies_file(file: UploadFile = File(...), format: str = "json"):
    if not file.filename.endswith(".txt"):
        raise HTTPException(status_code=400, detail="Only .txt files are supported")

    contents = await file.read()
    text = contents.decode("utf-8").lower()
    words = text.split()
    frequency = Counter(words)

    # 生成唯一的临时文件名
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    base_name = os.path.splitext(file.filename)[0]
    file_suffix = ".json" if format == "json" else ".csv"
    filename = f"{base_name}_freq_{timestamp}{file_suffix}"
    file_path = os.path.join(tempfile.gettempdir(), filename)

    # 根据格式写入文件
    if format == "json":
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump({"total_words": len(words), "frequencies": frequency}, f, indent=2)
    elif format == "csv":
        with open(file_path, "w", newline='', encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["word", "count"])
            writer.writerows(frequency.items())
    else:
        raise HTTPException(status_code=400, detail="Format must be 'json' or 'csv'")

    # 返回文件响应供用户下载
    return FileResponse(file_path, filename=filename, media_type="application/octet-stream")
```
**测试方法 (`curl`):**
```bash
# 下载 JSON 格式的结果
curl -X POST "http://localhost:8000/word_frequencies_file?format=json" -F "file=@test.txt" --output result.json

# 下载 CSV 格式的结果
curl -X POST "http://localhost:8000/word_frequencies_file?format=csv" -F "file=@test.txt" --output result.csv
```

#### **2.3 最佳实践：添加日志 (Loguru)**
为服务添加日志功能，方便追踪请求和排查问题。

1.  **安装 Loguru:**
    ```bash
    pip install loguru
    ```
2.  **在 `main.py` 中配置:**
    ```python
    from loguru import logger

    # 在 main.py 顶部配置日志，日志会自动轮转、压缩和清理
    logger.add("logs/app_{time}.log", rotation="1 MB", retention="10 days", compression="zip")

    # 在接口函数中添加日志记录
    @app.post("/word_frequencies_file")
    async def word_frequencies_file(file: UploadFile = File(...), format: str = "json"):
        logger.info(f"Received file upload: {file.filename}, requested format: {format}")
        # ... (原有逻辑) ...
        logger.success(f"Processed and served file: {file_path}")
        return FileResponse(...)
    ```

#### **2.4 最佳实践：限制上传文件大小**
通过中间件限制请求体的大小，防止恶意大文件攻击。

```python
# 在 main.py 顶部添加
from starlette.middleware.base import BaseHTTPMiddleware
from fastapi.responses import JSONResponse

MAX_FILE_SIZE = 1 * 1024 * 1024  # 1MB

class LimitUploadSizeMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        content_length = request.headers.get("content-length")
        if content_length and int(content_length) > MAX_FILE_SIZE:
            return JSONResponse(
                status_code=413, # 413 Request Entity Too Large
                content={"detail": f"File too large. Limit is {MAX_FILE_SIZE/1024/1024}MB."}
            )
        return await call_next(request)

# 在 app 初始化后添加中间件
app.add_middleware(LimitUploadSizeMiddleware)
```

#### **2.5 最佳实践：添加 API 身份验证**
为接口增加访问控制，确保只有授权用户才能使用。

*   **方法一：HTTP Basic Auth (简单场景)**
    ```python
    from fastapi import Depends
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    import secrets

    security = HTTPBasic()

    def verify_credentials(credentials: HTTPBasicCredentials = Depends(security)):
        # 在生产环境中，应使用更安全的方式存储和比较凭证
        is_user_ok = secrets.compare_digest(credentials.username, "admin")
        is_pass_ok = secrets.compare_digest(credentials.password, "supersecret")
        if not (is_user_ok and is_pass_ok):
            raise HTTPException(status_code=401, detail="Incorrect username or password")
        return credentials.username

    # 在需要保护的接口上添加依赖
    @app.post("/count_words", dependencies=[Depends(verify_credentials)])
    def count_words(request: WordCountRequest):
        # ...
    ```

*   **方法二：OAuth2 + JWT (标准做法)**
    适用于需要用户登录、Token 刷新等复杂场景。推荐参考 [FastAPI 官方文档](https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/)。

---

### **第三部分：生产部署**

#### **3.1 部署方式一：使用 Docker (推荐)**
将应用打包成一个隔离的、标准化的容器，实现“一次构建，处处运行”。

1.  **项目结构:**
    ```
    /your_project
    ├── main.py
    ├── requirements.txt
    └── Dockerfile
    ```

2.  **`requirements.txt` 文件:**
    ```
    fastapi
    uvicorn[standard]
    loguru
    ```

3.  **`Dockerfile` 文件:**
    ```dockerfile
    # 1. 使用官方 Python 3.11 slim 镜像作为基础
    FROM python:3.11-slim

    # 2. 设置容器内的工作目录
    WORKDIR /app

    # 3. 复制依赖文件并安装
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt

    # 4. 复制所有项目代码到工作目录
    COPY . .

    # 5. 定义容器启动时执行的命令
    # --host 0.0.0.0 使容器外部可以访问
    CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
    ```

4.  **构建 Docker 镜像:**
    ```bash
    docker build -t word-counter-api .
    ```

5.  **运行 Docker 容器:**
    ```bash
    docker run -d -p 8000:8000 --name word-counter-container word-counter-api
    ```
    *   `-d`: 后台运行
    *   `-p 8000:8000`: 将宿主机的 8000 端口映射到容器的 8000 端口
    *   `--name`: 为容器命名

现在，你可以通过 `http://localhost:8000/docs` 访问你的容器化应用了。

#### **3.2 部署方式二：直接部署到 Linux 云服务器**

1.  **连接服务器:** `ssh user@your_server_ip`
2.  **安装环境:** `sudo apt update && sudo apt install python3 python3-pip git -y`
3.  **上传代码:**
    *   **scp:** `scp -r ./your_project user@your_server_ip:/home/user/`
    *   **git:** `git clone https://github.com/your/repo.git`
4.  **安装依赖:** `cd your_project && pip3 install -r requirements.txt`
5.  **启动应用 (使用 `screen` 保持后台运行):**
    ```bash
    # 安装 screen
    sudo apt install screen -y
    # 创建并进入一个名为 "fastapi" 的会话
    screen -S fastapi
    # 在会话中启动应用
    uvicorn main:app --host 0.0.0.0 --port 8000
    # 按下 Ctrl+A 然后按 D，即可分离会话，程序会继续在后台运行
    # 若要恢复会话，使用 screen -r fastapi
    ```
6.  **(推荐) 配置 Nginx 反向代理:**
    使用 Nginx 监听 80 端口，并将流量转发到 FastAPI 应用的 8000 端口，这样更安全、更专业。
    ```bash
    sudo apt install nginx -y
    # 编辑 Nginx 配置
    sudo nano /etc/nginx/sites-available/default
    ```
    **示例配置:**
    ```nginx
    server {
        listen 80;
        server_name your_domain_or_ip;

        location / {
            proxy_pass http://127.0.0.1:8000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
    ```
    **重启 Nginx:** `sudo systemctl restart nginx`

7.  **(推荐) 配置 HTTPS:**
    使用 Let's Encrypt 提供的免费 SSL 证书。
    ```bash
    sudo apt install certbot python3-certbot-nginx -y
    sudo certbot --nginx
    ```