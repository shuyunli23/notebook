# JavaScript 完整语法笔记

## 目录
1. [基础语法](#一基础语法)
2. [数据类型](#二数据类型)
3. [数据结构](#三数据结构)
4. [控制流](#四控制流)
5. [函数](#五函数)
6. [面向对象](#六面向对象)
7. [模块系统](#七模块系统)
8. [异常处理](#八异常处理)
9. [异步编程](#九异步编程)
10. [DOM操作](#十dom操作)
11. [事件处理](#十一事件处理)
12. [高级特性](#十二高级特性)
13. [常用内置对象](#十三常用内置对象)

---

## 一、基础语法

### 变量声明
```javascript
// var - 函数作用域，可重复声明（不推荐）
var x = 10;

// let - 块作用域，不可重复声明
let y = 20;
y = 30;  // 可以重新赋值

// const - 块作用域，不可重新赋值
const z = 40;
// z = 50;  // ❌ 错误

// 对象和数组用const，内容可以改变
const obj = {name: 'Alice'};
obj.name = 'Bob';  // ✓ 可以修改属性
obj.age = 25;      // ✓ 可以添加属性

const arr = [1, 2, 3];
arr.push(4);       // ✓ 可以修改内容
// arr = [];       // ❌ 不能重新赋值
```

### 数据类型（7种原始类型 + 对象）
```javascript
// 原始类型（Primitive Types）
let num = 42;              // Number
let str = "hello";         // String
let bool = true;           // Boolean
let undef = undefined;     // Undefined
let n = null;              // Null
let sym = Symbol('id');    // Symbol (ES6)
let bigInt = 123n;         // BigInt (ES2020)

// 对象类型
let obj = {key: 'value'};  // Object
let arr = [1, 2, 3];       // Array（特殊对象）
let func = function() {};  // Function（特殊对象）

// 类型检查
typeof 42              // "number"
typeof "hello"         // "string"
typeof true            // "boolean"
typeof undefined       // "undefined"
typeof null            // "object" ⚠️ 历史bug
typeof Symbol()        // "symbol"
typeof 123n            // "bigint"
typeof {}              // "object"
typeof []              // "object"
typeof function(){}    // "function"

// 准确检查
Array.isArray([])      // true
value instanceof Array
```

### 运算符
```javascript
// 算术运算符
+    // 加
-    // 减
*    // 乘
/    // 除
%    // 取余
**   // 幂运算（ES2016）
++   // 自增
--   // 自减

// 比较运算符
==   // 相等（会类型转换）
===  // 严格相等（推荐）
!=   // 不等
!==  // 严格不等
>    // 大于
<    // 小于
>=   // 大于等于
<=   // 小于等于

// 逻辑运算符
&&   // 与
||   // 或
!    // 非
??   // 空值合并（ES2020）

// 位运算符
&    // 按位与
|    // 按位或
^    // 按位异或
~    // 按位非
<<   // 左移
>>   // 右移
>>>  // 无符号右移

// 赋值运算符
=    // 赋值
+=   // 加等于
-=   // 减等于
*=   // 乘等于
/=   // 除等于
&&=  // 逻辑与赋值（ES2021）
||=  // 逻辑或赋值（ES2021）
??=  // 空值合并赋值（ES2021）

// 三元运算符
condition ? value1 : value2

// 可选链操作符（ES2020）
obj?.property
obj?.[expression]
func?.()
```

### 类型转换
```javascript
// 转为字符串
String(123)           // "123"
(123).toString()      // "123"
123 + ""              // "123"

// 转为数字
Number("123")         // 123
parseInt("123")       // 123
parseFloat("3.14")    // 3.14
+"123"                // 123

// 转为布尔值
Boolean(0)            // false
Boolean("")           // false
Boolean(null)         // false
Boolean(undefined)    // false
Boolean(NaN)          // false
!!value               // 转为布尔值

// 假值（Falsy）
false, 0, "", null, undefined, NaN

// 其他都是真值（Truthy）
true, 1, "0", "false", [], {}, function(){}
```

### 注释
```javascript
// 单行注释

/*
多行注释
可以跨越多行
*/

/**
 * JSDoc 文档注释
 * @param {string} name - 参数说明
 * @returns {number} 返回值说明
 */
```

---

## 二、数据类型详解

### Number（数字）
```javascript
// 整数和浮点数
let int = 42;
let float = 3.14;
let exp = 2.5e6;        // 2500000

// 特殊值
Infinity                 // 无穷大
-Infinity                // 负无穷
NaN                      // Not a Number

// 检查
isNaN(NaN)              // true
isFinite(42)            // true
Number.isInteger(42)    // true

// 数学运算
Math.round(3.6)         // 4
Math.floor(3.9)         // 3
Math.ceil(3.1)          // 4
Math.abs(-5)            // 5
Math.max(1, 2, 3)       // 3
Math.min(1, 2, 3)       // 1
Math.random()           // [0, 1) 随机数
Math.pow(2, 3)          // 8
Math.sqrt(16)           // 4

// 转换和格式化
(3.14159).toFixed(2)    // "3.14"
(1234.5).toExponential()// "1.2345e+3"
(123).toString(2)       // "1111011" 二进制
parseInt("1111011", 2)  // 123
```

### String（字符串）
```javascript
// 创建字符串
let str1 = "双引号";
let str2 = '单引号';
let str3 = `模板字符串`;

// 模板字符串（ES6）
let name = "Alice";
let age = 25;
let msg = `我叫${name}，今年${age}岁`;
let multiline = `第一行
第二行
第三行`;

// 字符串属性和方法
str.length              // 长度
str[0]                  // 访问字符
str.charAt(0)           // 访问字符
str.charCodeAt(0)       // 字符编码

// 查找
str.indexOf('sub')      // 查找子串位置，-1表示未找到
str.lastIndexOf('sub')  // 从后查找
str.includes('sub')     // 是否包含（ES6）
str.startsWith('pre')   // 是否以...开头（ES6）
str.endsWith('suf')     // 是否以...结尾（ES6）
str.search(/pattern/)   // 正则查找

// 提取
str.slice(start, end)   // 切片
str.substring(start, end)
str.substr(start, length)  // 已废弃

// 修改（返回新字符串）
str.toLowerCase()       // 转小写
str.toUpperCase()       // 转大写
str.trim()              // 去除两端空白
str.trimStart()         // 去除开头空白（ES2019）
str.trimEnd()           // 去除结尾空白（ES2019）
str.repeat(3)           // 重复3次（ES6）
str.padStart(5, '0')    // 左侧填充（ES2017）
str.padEnd(5, '0')      // 右侧填充（ES2017）

// 替换
str.replace('old', 'new')     // 替换第一个
str.replaceAll('old', 'new')  // 替换所有（ES2021）
str.replace(/old/g, 'new')    // 正则全局替换

// 分割和连接
str.split(',')          // 分割为数组
arr.join(',')           // 数组连接为字符串
str.concat(str2)        // 连接字符串（不常用，一般用+）
```

### Boolean（布尔值）
```javascript
let isTrue = true;
let isFalse = false;

// 布尔转换
Boolean(1)              // true
Boolean(0)              // false
!!value                 // 双重取反转布尔

// 逻辑运算
true && false           // false
true || false           // true
!true                   // false

// 短路求值
value1 || value2        // 返回第一个真值
value1 && value2        // 返回第一个假值或最后一个真值
value1 ?? value2        // 只有null/undefined时返回value2
```

---

## 三、数据结构

### Array（数组）
```javascript
// 创建数组
let arr = [1, 2, 3];
let arr2 = new Array(5);        // 长度为5的空数组
let arr3 = Array.of(1, 2, 3);   // [1, 2, 3]
let arr4 = Array.from('abc');   // ['a', 'b', 'c']

// 访问和修改
arr[0]                  // 访问第一个元素
arr[arr.length - 1]     // 访问最后一个元素
arr.at(-1)              // 访问最后一个（ES2022）
arr[0] = 10             // 修改元素

// 添加元素
arr.push(4)             // 末尾添加，返回新长度
arr.unshift(0)          // 开头添加，返回新长度
arr.splice(2, 0, 'a')   // 在索引2插入'a'

// 删除元素
arr.pop()               // 删除末尾，返回删除的元素
arr.shift()             // 删除开头，返回删除的元素
arr.splice(1, 2)        // 从索引1删除2个元素
delete arr[1]           // 删除但留下空位（不推荐）

// 切片和拼接
arr.slice(1, 3)         // 切片 [起始, 结束)
arr.concat([4, 5])      // 连接数组
[...arr1, ...arr2]      // 扩展运算符连接（ES6）

// 查找
arr.indexOf(2)          // 查找索引
arr.lastIndexOf(2)      // 从后查找
arr.includes(2)         // 是否包含（ES7）
arr.find(x => x > 2)    // 查找第一个满足条件的
arr.findIndex(x => x > 2) // 查找索引（ES6）

// 遍历
arr.forEach((item, index) => {
    console.log(item, index);
});

for (let item of arr) {
    console.log(item);
}

for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

// 转换
arr.map(x => x * 2)     // 映射
arr.filter(x => x > 2)  // 过滤
arr.reduce((sum, x) => sum + x, 0)  // 归约

// 排序和反转
arr.sort()              // 排序（原地）
arr.sort((a, b) => a - b)  // 数字排序
arr.reverse()           // 反转（原地）

// 其他方法
arr.join(',')           // 连接为字符串
arr.toString()          // 转为字符串
arr.flat()              // 扁平化一层（ES2019）
arr.flat(Infinity)      // 完全扁平化
arr.flatMap(x => [x, x * 2])  // map + flat
arr.fill(0)             // 填充
arr.every(x => x > 0)   // 是否全部满足
arr.some(x => x > 0)    // 是否有满足的

// 解构
let [a, b, c] = [1, 2, 3];
let [first, ...rest] = [1, 2, 3, 4];  // rest = [2, 3, 4]
let [x, , z] = [1, 2, 3];  // x=1, z=3，跳过中间
```

### Object（对象）
```javascript
// 创建对象
let obj = {
    name: 'Alice',
    age: 25,
    'full name': 'Alice Wang',  // 带空格的键
    sayHi() {                   // 方法简写（ES6）
        console.log('Hi!');
    }
};

let obj2 = new Object();
let obj3 = Object.create(proto);  // 指定原型创建

// 访问属性
obj.name                // 点表示法
obj['name']             // 括号表示法
obj['full name']        // 必须用括号

// 添加/修改属性
obj.city = 'Beijing';
obj['country'] = 'China';

// 删除属性
delete obj.age;

// 检查属性
'name' in obj           // true
obj.hasOwnProperty('name')  // true（不检查原型链）

// 遍历
for (let key in obj) {
    console.log(key, obj[key]);
}

Object.keys(obj)        // 返回键数组
Object.values(obj)      // 返回值数组（ES2017）
Object.entries(obj)     // 返回键值对数组（ES2017）

Object.entries(obj).forEach(([key, value]) => {
    console.log(key, value);
});

// 对象方法
Object.assign({}, obj1, obj2)  // 合并对象
{...obj1, ...obj2}      // 扩展运算符合并（ES2018）

Object.freeze(obj)      // 冻结对象（不可修改）
Object.seal(obj)        // 封闭对象（不可添加/删除）
Object.preventExtensions(obj)  // 不可扩展

// 属性描述符
Object.defineProperty(obj, 'prop', {
    value: 42,
    writable: true,      // 可写
    enumerable: true,    // 可枚举
    configurable: true   // 可配置
});

Object.getOwnPropertyDescriptor(obj, 'prop');

// Getter和Setter
let person = {
    firstName: 'John',
    lastName: 'Doe',
    get fullName() {
        return `${this.firstName} ${this.lastName}`;
    },
    set fullName(value) {
        [this.firstName, this.lastName] = value.split(' ');
    }
};

// 解构
let {name, age} = obj;
let {name: n, age: a} = obj;  // 重命名
let {name = 'Default'} = obj;  // 默认值
let {name, ...rest} = obj;     // 剩余属性
```

### Map（映射）
```javascript
// 创建Map
let map = new Map();
let map2 = new Map([
    ['key1', 'value1'],
    ['key2', 'value2']
]);

// 操作
map.set('name', 'Alice');
map.set(123, 'number key');  // 键可以是任意类型
map.set({}, 'object key');

map.get('name')         // 'Alice'
map.has('name')         // true
map.delete('name')      // 删除
map.clear()             // 清空
map.size                // 大小

// 遍历
map.forEach((value, key) => {
    console.log(key, value);
});

for (let [key, value] of map) {
    console.log(key, value);
}

for (let key of map.keys()) { }
for (let value of map.values()) { }
for (let [key, value] of map.entries()) { }

// 转换
Array.from(map)         // 转为数组
Object.fromEntries(map) // 转为对象（ES2019）
```

### Set（集合）
```javascript
// 创建Set
let set = new Set();
let set2 = new Set([1, 2, 2, 3]);  // {1, 2, 3} 自动去重

// 操作
set.add(1);
set.add(2);
set.add(2);             // 重复添加无效

set.has(1)              // true
set.delete(1)           // 删除
set.clear()             // 清空
set.size                // 大小

// 遍历
set.forEach(value => {
    console.log(value);
});

for (let value of set) {
    console.log(value);
}

// 转换
Array.from(set)         // 转为数组
[...set]                // 扩展运算符转为数组

// 数组去重
let arr = [1, 2, 2, 3, 3];
let unique = [...new Set(arr)];

// 集合运算
let a = new Set([1, 2, 3]);
let b = new Set([2, 3, 4]);

// 并集
let union = new Set([...a, ...b]);

// 交集
let intersection = new Set([...a].filter(x => b.has(x)));

// 差集
let difference = new Set([...a].filter(x => !b.has(x)));
```

### WeakMap 和 WeakSet
```javascript
// WeakMap - 键必须是对象，弱引用
let wm = new WeakMap();
let obj = {};
wm.set(obj, 'value');
// 当obj没有其他引用时，会被垃圾回收

// WeakSet - 只能存储对象，弱引用
let ws = new WeakSet();
ws.add(obj);
```

---

## 四、控制流

### 条件语句
```javascript
// if-else
if (condition) {
    // 代码块
} else if (anotherCondition) {
    // 代码块
} else {
    // 代码块
}

// 三元运算符
let result = condition ? value1 : value2;

// switch
switch (value) {
    case 1:
        // 代码块
        break;
    case 2:
    case 3:
        // 多个case共享代码
        break;
    default:
        // 默认代码
}
```

### 循环
```javascript
// for循环
for (let i = 0; i < 10; i++) {
    console.log(i);
}

// for...of（遍历值）- 可迭代对象
for (let item of array) {
    console.log(item);
}

for (let char of string) {
    console.log(char);
}

// for...in（遍历键）- 对象属性
for (let key in object) {
    console.log(key, object[key]);
}

// while循环
while (condition) {
    // 代码块
}

// do...while循环
do {
    // 至少执行一次
} while (condition);

// 控制语句
break;      // 跳出循环
continue;   // 跳过本次迭代

// 标签（用于嵌套循环）
outer: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) {
            break outer;  // 跳出外层循环
        }
    }
}
```

---

## 五、函数

### 函数定义
```javascript
// 函数声明（会提升）
function greet(name) {
    return `Hello, ${name}!`;
}

// 函数表达式
const greet = function(name) {
    return `Hello, ${name}!`;
};

// 箭头函数（ES6）
const greet = (name) => {
    return `Hello, ${name}!`;
};

// 简写形式
const greet = name => `Hello, ${name}!`;
const add = (a, b) => a + b;

// 立即执行函数（IIFE）
(function() {
    console.log('立即执行');
})();

(() => {
    console.log('箭头函数IIFE');
})();
```

### 参数
```javascript
// 默认参数（ES6）
function greet(name = 'Guest') {
    return `Hello, ${name}!`;
}

// 剩余参数（ES6）
function sum(...numbers) {
    return numbers.reduce((a, b) => a + b, 0);
}
sum(1, 2, 3, 4);  // 10

// 解构参数
function printUser({name, age}) {
    console.log(name, age);
}
printUser({name: 'Alice', age: 25});

// arguments对象（箭头函数没有）
function oldStyle() {
    console.log(arguments[0]);  // 第一个参数
}
```

### 返回值
```javascript
function add(a, b) {
    return a + b;
}

// 没有return语句返回undefined
function noReturn() {
    // 什么都不做
}
noReturn();  // undefined

// 提前返回
function check(value) {
    if (!value) return;
    // 继续处理
}
```

### 箭头函数特性
```javascript
// this绑定不同
const obj = {
    name: 'Alice',
    regularFunc: function() {
        console.log(this.name);  // 'Alice'
    },
    arrowFunc: () => {
        console.log(this.name);  // undefined（this指向外层）
    }
};

// 不能作为构造函数
const Person = (name) => {
    this.name = name;
};
// new Person('Alice');  // ❌ 错误

// 没有arguments对象
const func = () => {
    // console.log(arguments);  // ❌ 错误
};
```

### 高阶函数
```javascript
// 接受函数作为参数
function repeat(n, action) {
    for (let i = 0; i < n; i++) {
        action(i);
    }
}
repeat(3, console.log);

// 返回函数
function multiplier(factor) {
    return number => number * factor;
}
let double = multiplier(2);
console.log(double(5));  // 10

// 函数组合
const compose = (f, g) => x => f(g(x));
const addOne = x => x + 1;
const double = x => x * 2;
const addOneThenDouble = compose(double, addOne);
```

### 闭包
```javascript
function createCounter() {
    let count = 0;
    return {
        increment() {
            return ++count;
        },
        decrement() {
            return --count;
        },
        getCount() {
            return count;
        }
    };
}

let counter = createCounter();
counter.increment();  // 1
counter.increment();  // 2
counter.getCount();   // 2

// 闭包陷阱
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);  // 输出: 3, 3, 3
}

// 解决方案1: 使用let
for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);  // 输出: 0, 1, 2
}

// 解决方案2: 闭包
for (var i = 0; i < 3; i++) {
    ((i) => {
        setTimeout(() => console.log(i), 100);
    })(i);
}
```

### 递归
```javascript
// 阶乘
function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

// 斐波那契
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// 尾递归优化
function factorial(n, acc = 1) {
    if (n <= 1) return acc;
    return factorial(n - 1, n * acc);
}
```

---

## 六、面向对象

### 对象字面量
```javascript
let person = {
    name: 'Alice',
    age: 25,
    greet() {
        console.log(`Hi, I'm ${this.name}`);
    }
};

// 计算属性名（ES6）
let prop = 'age';
let obj = {
    [prop]: 25,
    ['key' + 1]: 'value1'
};

// 属性简写（ES6）
let name = 'Alice';
let age = 25;
let person = {name, age};  // 等价于 {name: name, age: age}
```

### 构造函数
```javascript
// 构造函数（传统方式）
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log(`Hi, I'm ${this.name}`);
};

let alice = new Person('Alice', 25);
alice.greet();

// new 做了什么：
// 1. 创建空对象
// 2. 设置原型
// 3. 执行构造函数
// 4. 返回对象
```

### Class类（ES6）
```javascript
// 类定义
class Person {
    // 构造函数
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // 实例方法
    greet() {
        console.log(`Hi, I'm ${this.name}`);
    }
    
    // Getter
    get info() {
        return `${this.name}, ${this.age}`;
    }
    
    // Setter
    set info(value) {
        [this.name, this.age] = value.split(',');
    }
    
    // 静态方法
    static species() {
        return 'Homo sapiens';
    }
    
    // 私有字段（ES2022）
    #privateField = 'private';
    
    getPrivate() {
        return this.#privateField;
    }
}

let alice = new Person('Alice', 25);
alice.greet();
Person.species();  // 调用静态方法
```

### 继承
```javascript
// 类继承
class Student extends Person {
    constructor(name, age, grade) {
        super(name, age);  // 调用父类构造函数
        this.grade = grade;
    }
    
    // 重写方法
    greet() {
        super.greet();  // 调用父类方法
        console.log(`I'm in grade ${this.grade}`);
    }
    
    // 新方法
    study() {
        console.log('Studying...');
    }
}

let bob = new Student('Bob', 18, 12);
bob.greet();

// 原型链继承（传统方式）
function Student(name, age, grade) {
    Person.call(this, name, age);
    this.grade = grade;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
```

### 原型链
```javascript
// 每个对象都有原型
let obj = {};
Object.getPrototypeOf(obj) === Object.prototype;  // true

// 原型链
function Person(name) {
    this.name = name;
}
Person.prototype.greet = function() {
    console.log(this.name);
};

let alice = new Person('Alice');
alice.greet();  // 查找顺序: alice -> Person.prototype -> Object.prototype

// 检查原型
alice instanceof Person;  // true
Person.prototype.isPrototypeOf(alice);  // true
alice.hasOwnProperty('name');  // true
alice.hasOwnProperty('greet');  // false（在原型上）
```

### this关键字
```javascript
// this的四种绑定
// 1. 默认绑定
function foo() {
    console.log(this);  // window（非严格模式）或undefined（严格模式）
}

// 2. 隐式绑定
let obj = {
    name: 'Alice',
    greet() {
        console.log(this.name);  // this指向obj
    }
};

// 3. 显式绑定
function greet() {
    console.log(this.name);
}
let person = {name: 'Alice'};
greet.call(person);      // 立即调用
greet.apply(person);     // 立即调用
let boundGreet = greet.bind(person);  // 返回新函数

// 4. new绑定
function Person(name) {
    this.name = name;  // this指向新创建的对象
}
let alice = new Person('Alice');

// 箭头函数的this
let obj = {
    name: 'Alice',
    regularFunc: function() {
        console.log(this.name);  // 'Alice'
    },
    arrowFunc: () => {
        console.log(this.name);  // undefined（继承外层this）
    }
};
```

---

## 七、模块系统

### ES6 Modules（现代方式）
```javascript
// 导出 - export.js
export const PI = 3.14;
export function add(a, b) {
    return a + b;
}
export class Person {
    constructor(name) {
        this.name = name;
    }
}

// 默认导出（每个模块只能有一个）
export default function greet(name) {
    return `Hello, ${name}!`;
}

// 或者
const config = {
    apiUrl: 'https://api.example.com'
};
export default config;

// 导入 - import.js
import greet from './export.js';           // 导入默认
import { PI, add, Person } from './export.js';  // 导入具名
import { add as sum } from './export.js';  // 重命名
import * as utils from './export.js';      // 导入全部
import greet, { PI } from './export.js';   // 混合导入

// 动态导入（ES2020）
async function loadModule() {
    const module = await import('./export.js');
    module.add(1, 2);
}

// 或用Promise
import('./export.js').then(module => {
    module.add(1, 2);
});
```

### CommonJS（Node.js）
```javascript
// 导出 - module.js
const PI = 3.14;
function add(a, b) {
    return a + b;
}

module.exports = {
    PI,
    add
};

// 或单个导出
module.exports = function greet(name) {
    return `Hello, ${name}!`;
};

// 导入 - app.js
const { PI, add } = require('./module.js');
const greet = require('./greet.js');

// 内置模块
const fs = require('fs');
const path = require('path');
```

---

## 八、异常处理

### try-catch-finally
```javascript
try {
    // 可能出错的代码
    riskyOperation();
} catch (error) {
    // 处理错误
    console.error(error.message);
    console.error(error.stack);
} finally {
    // 无论如何都执行
    cleanup();
}

// 特定错误类型
try {
    JSON.parse('invalid json');
} catch (error) {
    if (error instanceof SyntaxError) {
        console.log('JSON语法错误');
    } else {
        throw error;  // 重新抛出
    }
}
```

### 抛出异常
```javascript
// 抛出错误
throw new Error('出错了');
throw new TypeError('类型错误');
throw new RangeError('范围错误');

// 自定义错误
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ValidationError';
    }
}

throw new ValidationError('验证失败');

// 抛出任意值（不推荐）
throw 'Error message';
throw { message: 'Error' };
```

### 错误类型
```javascript
Error           // 通用错误
SyntaxError     // 语法错误
TypeError       // 类型错误
ReferenceError  // 引用错误
RangeError      // 范围错误
URIError        // URI错误
EvalError       // eval错误
```

---

## 九、异步编程

### 回调函数（Callback）
```javascript
// 传统回调
function fetchData(callback) {
    setTimeout(() => {
        callback('数据');
    }, 1000);
}

fetchData((data) => {
    console.log(data);
});

// 回调地狱
getData(function(a) {
    getMoreData(a, function(b) {
        getMoreData(b, function(c) {
            getMoreData(c, function(d) {
                // 嵌套太深
            });
        });
    });
});
```

### Promise
```javascript
// 创建Promise
let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        if (Math.random() > 0.5) {
            resolve('成功');
        } else {
            reject('失败');
        }
    }, 1000);
});

// 使用Promise
promise
    .then(result => {
        console.log(result);
        return '下一步';
    })
    .then(result => {
        console.log(result);
    })
    .catch(error => {
        console.error(error);
    })
    .finally(() => {
        console.log('完成');
    });

// Promise链式调用
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => processData(data))
    .then(result => saveResult(result))
    .catch(error => console.error(error));

// Promise静态方法
Promise.resolve(value);     // 返回成功的Promise
Promise.reject(error);      // 返回失败的Promise

Promise.all([p1, p2, p3])   // 全部成功才成功
    .then(results => {
        // results是数组
    });

Promise.race([p1, p2])      // 第一个完成的
    .then(result => {
        // 最快的结果
    });

Promise.allSettled([p1, p2])  // 等待全部完成（ES2020）
    .then(results => {
        // [{status: 'fulfilled', value: ...}, ...]
    });

Promise.any([p1, p2])       // 第一个成功的（ES2021）
    .then(result => {
        // 第一个成功的结果
    });
```

### Async/Await（ES2017）
```javascript
// async函数返回Promise
async function fetchData() {
    return '数据';  // 自动包装为Promise
}

fetchData().then(data => console.log(data));

// await等待Promise
async function getData() {
    try {
        let response = await fetch('https://api.example.com');
        let data = await response.json();
        return data;
    } catch (error) {
        console.error(error);
    }
}

// 并发执行
async function parallel() {
    // 方式1: Promise.all
    let [result1, result2] = await Promise.all([
        fetchData1(),
        fetchData2()
    ]);
    
    // 方式2: 先启动再等待
    let promise1 = fetchData1();
    let promise2 = fetchData2();
    let result1 = await promise1;
    let result2 = await promise2;
}

// 顺序执行
async function sequential() {
    let result1 = await fetchData1();
    let result2 = await fetchData2();
}

// 错误处理
async function handleErrors() {
    try {
        let data = await fetchData();
    } catch (error) {
        console.error(error);
    }
}

// 在顶层使用await（ES2022）
// 在模块的顶层可以直接使用await
let data = await fetch('https://api.example.com');
```

### 定时器
```javascript
// setTimeout - 延迟执行
let timerId = setTimeout(() => {
    console.log('1秒后执行');
}, 1000);

clearTimeout(timerId);  // 取消

// setInterval - 重复执行
let intervalId = setInterval(() => {
    console.log('每秒执行');
}, 1000);

clearInterval(intervalId);  // 取消

// 模拟sleep
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function demo() {
    console.log('开始');
    await sleep(2000);
    console.log('2秒后');
}
```

---

## 十、DOM操作

### 选择元素
```javascript
// 获取单个元素
document.getElementById('myId');
document.querySelector('.myClass');      // CSS选择器
document.querySelector('#myId');

// 获取多个元素（返回NodeList/HTMLCollection）
document.getElementsByClassName('myClass');
document.getElementsByTagName('div');
document.querySelectorAll('.myClass');   // CSS选择器

// 转为数组
Array.from(document.querySelectorAll('div'));
[...document.querySelectorAll('div')];
```

### 修改内容
```javascript
let element = document.getElementById('myDiv');

// HTML内容
element.innerHTML = '<p>新内容</p>';

// 文本内容
element.textContent = '纯文本';
element.innerText = '纯文本（考虑样式）';

// 属性
element.getAttribute('data-id');
element.setAttribute('data-id', '123');
element.removeAttribute('data-id');
element.hasAttribute('data-id');

// 常用属性直接访问
element.id = 'newId';
element.className = 'newClass';
element.value = '表单值';
element.href = 'https://example.com';

// 样式
element.style.color = 'red';
element.style.backgroundColor = 'blue';
element.style.fontSize = '16px';

// CSS类
element.classList.add('active');
element.classList.remove('active');
element.classList.toggle('active');
element.classList.contains('active');
element.classList.replace('old', 'new');
```

### 创建和删除元素
```javascript
// 创建元素
let div = document.createElement('div');
let text = document.createTextNode('文本');
let fragment = document.createDocumentFragment();  // 文档片段

// 添加元素
parent.appendChild(child);           // 末尾添加
parent.insertBefore(new, existing);  // 在existing前插入
parent.replaceChild(new, old);       // 替换

// 现代方法（更方便）
element.append(...nodes);            // 末尾添加（可多个）
element.prepend(...nodes);           // 开头添加
element.before(...nodes);            // 前面插入
element.after(...nodes);             // 后面插入
element.replaceWith(...nodes);       // 替换

// 删除元素
parent.removeChild(child);
element.remove();                    // 自己删除自己

// 克隆元素
let clone = element.cloneNode(true);  // true表示深克隆
```

### 遍历DOM
```javascript
let element = document.getElementById('myDiv');

// 父节点
element.parentNode;
element.parentElement;
element.closest('.ancestor');  // 最近的匹配祖先

// 子节点
element.children;              // HTMLCollection（只包含元素）
element.childNodes;            // NodeList（包含文本节点）
element.firstElementChild;
element.lastElementChild;

// 兄弟节点
element.nextElementSibling;
element.previousElementSibling;

// 检查
element.contains(otherElement);
element.matches('.myClass');   // 是否匹配选择器
```

---

## 十一、事件处理

### 添加事件监听
```javascript
// addEventListener
element.addEventListener('click', function(event) {
    console.log('点击了', event);
});

// 箭头函数
element.addEventListener('click', (event) => {
    console.log('点击了');
});

// 第三个参数：选项
element.addEventListener('click', handler, {
    capture: false,  // 捕获阶段
    once: true,      // 只执行一次
    passive: true    // 不会调用preventDefault
});

// 移除监听（需要具名函数）
function handleClick(event) {
    console.log('点击了');
}
element.addEventListener('click', handleClick);
element.removeEventListener('click', handleClick);
```

### 常用事件
```javascript
// 鼠标事件
'click'         // 点击
'dblclick'      // 双击
'mousedown'     // 按下
'mouseup'       // 释放
'mousemove'     // 移动
'mouseenter'    // 进入（不冒泡）
'mouseleave'    // 离开（不冒泡）
'mouseover'     // 进入（冒泡）
'mouseout'      // 离开（冒泡）

// 键盘事件
'keydown'       // 按键按下
'keyup'         // 按键释放
'keypress'      // 已废弃

// 表单事件
'submit'        // 提交
'input'         // 输入变化
'change'        // 值改变且失去焦点
'focus'         // 获得焦点
'blur'          // 失去焦点

// 文档事件
'DOMContentLoaded'  // DOM加载完成
'load'              // 资源加载完成
'unload'            // 页面卸载
'resize'            // 窗口大小改变
'scroll'            // 滚动

// 触摸事件
'touchstart'
'touchmove'
'touchend'
```

### 事件对象
```javascript
element.addEventListener('click', (event) => {
    // 事件信息
    event.type;              // 事件类型
    event.target;            // 触发事件的元素
    event.currentTarget;     // 绑定事件的元素（this）
    event.timeStamp;         // 时间戳
    
    // 鼠标位置
    event.clientX;           // 相对于视口
    event.clientY;
    event.pageX;             // 相对于页面
    event.pageY;
    event.offsetX;           // 相对于目标元素
    event.offsetY;
    
    // 键盘信息
    event.key;               // 按键值
    event.code;              // 按键代码
    event.altKey;            // Alt键是否按下
    event.ctrlKey;           // Ctrl键
    event.shiftKey;          // Shift键
    event.metaKey;           // Meta键（Mac的Cmd）
    
    // 阻止默认行为
    event.preventDefault();
    
    // 阻止冒泡
    event.stopPropagation();
    
    // 阻止其他监听器
    event.stopImmediatePropagation();
});
```

### 事件委托
```javascript
// 利用事件冒泡，在父元素上监听子元素事件
document.getElementById('list').addEventListener('click', (event) => {
    if (event.target.tagName === 'LI') {
        console.log('点击了列表项:', event.target.textContent);
    }
});

// 好处：
// 1. 性能更好（只有一个监听器）
// 2. 动态添加的元素也能响应
```

### 自定义事件
```javascript
// 创建自定义事件
let event = new CustomEvent('myEvent', {
    detail: { message: '自定义数据' },
    bubbles: true,
    cancelable: true
});

// 触发事件
element.dispatchEvent(event);

// 监听自定义事件
element.addEventListener('myEvent', (event) => {
    console.log(event.detail.message);
});
```

---

## 十二、高级特性

### 解构赋值
```javascript
// 数组解构
let [a, b, c] = [1, 2, 3];
let [first, , third] = [1, 2, 3];  // 跳过元素
let [x, ...rest] = [1, 2, 3, 4];   // rest = [2, 3, 4]
let [a = 0, b = 0] = [1];          // 默认值

// 对象解构
let {name, age} = {name: 'Alice', age: 25};
let {name: n, age: a} = obj;       // 重命名
let {name = 'Default'} = obj;      // 默认值
let {name, ...rest} = obj;         // 剩余属性

// 嵌套解构
let {user: {name, age}} = {user: {name: 'Alice', age: 25}};

// 函数参数解构
function printUser({name, age}) {
    console.log(name, age);
}

// 交换变量
[a, b] = [b, a];
```

### 扩展运算符（...）
```javascript
// 数组
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let combined = [...arr1, ...arr2];  // [1, 2, 3, 4, 5, 6]
let copy = [...arr1];               // 浅拷贝

// 对象
let obj1 = {a: 1, b: 2};
let obj2 = {b: 3, c: 4};
let merged = {...obj1, ...obj2};    // {a: 1, b: 3, c: 4}
let copy = {...obj1};               // 浅拷贝

// 函数参数
Math.max(...[1, 2, 3]);             // 等价于 Math.max(1, 2, 3)

// 转为数组
let str = 'hello';
let chars = [...str];               // ['h', 'e', 'l', 'l', 'o']
let divs = [...document.querySelectorAll('div')];
```

### Symbol
```javascript
// 创建唯一标识符
let sym1 = Symbol('description');
let sym2 = Symbol('description');
sym1 === sym2;  // false，每个Symbol都是唯一的

// 作为对象属性
let obj = {
    [sym1]: 'value'
};
obj[sym1];  // 'value'

// Symbol不会出现在for...in和Object.keys中
for (let key in obj) { }  // 不包含Symbol
Object.keys(obj);         // 不包含Symbol
Object.getOwnPropertySymbols(obj);  // 获取Symbol属性

// 内置Symbol
Symbol.iterator       // 迭代器
Symbol.toStringTag    // toString标签
Symbol.hasInstance    // instanceof行为
```

### 迭代器和生成器
```javascript
// 迭代器
let iterator = {
    current: 0,
    last: 5,
    [Symbol.iterator]() {
        return this;
    },
    next() {
        if (this.current < this.last) {
            return { value: this.current++, done: false };
        } else {
            return { done: true };
        }
    }
};

for (let value of iterator) {
    console.log(value);  // 0, 1, 2, 3, 4
}

// 生成器函数
function* numberGenerator() {
    yield 1;
    yield 2;
    yield 3;
}

let gen = numberGenerator();
gen.next();  // {value: 1, done: false}
gen.next();  // {value: 2, done: false}
gen.next();  // {value: 3, done: false}
gen.next();  // {done: true}

// 使用for...of
for (let num of numberGenerator()) {
    console.log(num);  // 1, 2, 3
}

// 生成器委托
function* gen1() {
    yield 1;
    yield 2;
}

function* gen2() {
    yield* gen1();  // 委托给gen1
    yield 3;
}

// 无限序列
function* fibonacci() {
    let [a, b] = [0, 1];
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}
```

### Proxy和Reflect
```javascript
// Proxy - 拦截对象操作
let target = {name: 'Alice'};
let proxy = new Proxy(target, {
    get(target, property) {
        console.log(`读取 ${property}`);
        return target[property];
    },
    set(target, property, value) {
        console.log(`设置 ${property} = ${value}`);
        target[property] = value;
        return true;
    },
    has(target, property) {
        console.log(`检查 ${property}`);
        return property in target;
    },
    deleteProperty(target, property) {
        console.log(`删除 ${property}`);
        delete target[property];
        return true;
    }
});

proxy.name;           // 触发get
proxy.age = 25;       // 触发set
'name' in proxy;      // 触发has
delete proxy.age;     // 触发deleteProperty

// Reflect - 反射API
Reflect.get(obj, 'prop');
Reflect.set(obj, 'prop', value);
Reflect.has(obj, 'prop');
Reflect.deleteProperty(obj, 'prop');
Reflect.apply(func, thisArg, args);
Reflect.construct(constructor, args);
```

### 正则表达式
```javascript
// 创建正则
let regex1 = /pattern/flags;
let regex2 = new RegExp('pattern', 'flags');

// 标志
'g'  // 全局匹配
'i'  // 忽略大小写
'm'  // 多行模式
's'  // dotAll模式（.匹配换行符）
'u'  // Unicode模式
'y'  // 粘性匹配

// 测试和匹配
regex.test(str);              // 返回布尔值
str.match(regex);             // 返回匹配数组
str.matchAll(regex);          // 返回迭代器（需要g标志）
str.search(regex);            // 返回索引
str.replace(regex, replacement);
str.replaceAll(regex, replacement);  // 需要g标志
str.split(regex);

// 捕获组
let regex = /(\d{4})-(\d{2})-(\d{2})/;
let match = '2024-01-15'.match(regex);
match[0];  // '2024-01-15'
match[1];  // '2024'
match[2];  // '01'
match[3];  // '15'

// 命名捕获组
let regex = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
let match = '2024-01-15'.match(regex);
match.groups.year;   // '2024'
match.groups.month;  // '01'
match.groups.day;    // '15'

// 常用模式
\d   // 数字
\w   // 字母数字下划线
\s   // 空白字符
.    // 任意字符（除换行符）
^    // 开头
$    // 结尾
*    // 0次或多次
+    // 1次或多次
?    // 0次或1次
{n}  // 恰好n次
{n,} // 至少n次
{n,m}// n到m次
```

### JSON操作
```javascript
// 对象转JSON字符串
let obj = {name: 'Alice', age: 25};
let json = JSON.stringify(obj);
// '{"name":"Alice","age":25}'

// 格式化输出
JSON.stringify(obj, null, 2);  // 缩进2空格

// 自定义序列化
JSON.stringify(obj, ['name']);  // 只包含name属性
JSON.stringify(obj, (key, value) => {
    if (key === 'age') return undefined;  // 排除age
    return value;
});

// JSON字符串转对象
let parsed = JSON.parse(json);

// 自定义解析
JSON.parse(json, (key, value) => {
    if (key === 'date') return new Date(value);
    return value;
});

// 深拷贝（简单对象）
let copy = JSON.parse(JSON.stringify(obj));
// ⚠️ 不能处理函数、undefined、Symbol、循环引用
```

### 本地存储
```javascript
// localStorage - 永久存储
localStorage.setItem('key', 'value');
localStorage.getItem('key');
localStorage.removeItem('key');
localStorage.clear();
localStorage.key(0);  // 获取第n个键
localStorage.length;  // 项目数量

// 存储对象
localStorage.setItem('user', JSON.stringify({name: 'Alice'}));
let user = JSON.parse(localStorage.getItem('user'));

// sessionStorage - 会话存储（关闭标签页后清除）
sessionStorage.setItem('key', 'value');
sessionStorage.getItem('key');

// Cookie
document.cookie = 'name=Alice; max-age=3600; path=/';
document.cookie;  // 读取所有cookie

// 解析cookie
function getCookie(name) {
    let matches = document.cookie.match(
        new RegExp(`(?:^|; )${name}=([^;]*)`)
    );
    return matches ? decodeURIComponent(matches[1]) : undefined;
}
```

---

## 十三、常用内置对象

### Math
```javascript
Math.PI            // 3.141592653589793
Math.E             // 2.718281828459045

Math.abs(-5)       // 5
Math.ceil(4.3)     // 5
Math.floor(4.7)    // 4
Math.round(4.5)    // 5
Math.trunc(4.7)    // 4（截断小数）

Math.max(1, 2, 3)  // 3
Math.min(1, 2, 3)  // 1

Math.pow(2, 3)     // 8
Math.sqrt(16)      // 4
Math.cbrt(27)      // 3（立方根）

Math.random()      // [0, 1)随机数
Math.floor(Math.random() * 10)  // [0, 10)随机整数

Math.sin(Math.PI/2)  // 1
Math.cos(0)          // 1
Math.tan(Math.PI/4)  // 1

Math.log(Math.E)     // 1（自然对数）
Math.log10(100)      // 2（以10为底）
Math.log2(8)         // 3（以2为底）
```

### Date
```javascript
// 创建日期
let now = new Date();
let date = new Date('2024-01-15');
let date = new Date(2024, 0, 15);  // 月份从0开始
let date = new Date(timestamp);

// 获取时间戳
Date.now();
date.getTime();
+date;

// 获取日期部分
date.getFullYear()    // 年
date.getMonth()       // 月（0-11）
date.getDate()        // 日
date.getDay()         // 星期（0-6，0是周日）
date.getHours()       // 小时
date.getMinutes()     // 分钟
date.getSeconds()     // 秒
date.getMilliseconds()// 毫秒

// 设置日期部分
date.setFullYear(2025);
date.setMonth(11);
date.setDate(25);

// 格式化
date.toISOString()          // '2024-01-15T00:00:00.000Z'
date.toDateString()         // 'Mon Jan 15 2024'
date.toTimeString()         // '00:00:00 GMT+0800'
date.toLocaleDateString()   // '2024/1/15'（根据本地）
date.toLocaleTimeString()   // '上午12:00:00'
date.toLocaleString('zh-CN', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
});

// 时间计算
let tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000);
let diff = date2 - date1;  // 毫秒差
```

### RegExp
```javascript
let regex = /pattern/gi;

regex.test(str)        // 测试是否匹配
regex.exec(str)        // 返回匹配信息
regex.source           // 正则源码
regex.flags            // 标志
regex.lastIndex        // 下次匹配的起始位置（g标志时）
```